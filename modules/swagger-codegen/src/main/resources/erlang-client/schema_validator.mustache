-module({{packageName}}_schema_validator).

-behaviour(jesse_schema_validator).

%% API
-export([validate/2]).

%% Behaviour callbacks
-export([init_state/0]).
-export([check_value/3]).

-define(DISCRIMINATOR, <<"discriminator">>).
-define(FORMAT,        <<"format">>).
-define(REF,           <<"$ref">>).
-define(DEFINITIONS,   "definitions").
-define(NOT_FOUND,     not_found).

-define(DISCR_ERROR(Error), {discriminator_not_valid, Error}).

%%
-spec init_state() ->
    [].
init_state() ->
    [].

-spec validate(
    Value   :: {{packageName}}:value(),
    DefName :: {{packageName}}:param_name()
) ->
    ok | {error, Error :: {{packageName}}:error_reason()}.
validate(Value, DefName) ->
    validate(Value, DefName, {{packageName}}_schema:get()).

validate(Value, DefName, Schema) ->
    case jesse:validate_definition({{packageName}}_utils:to_list(DefName), Schema, Value, options()) of
        {ok, _} ->
            ok;
        {error, [Error]} ->
            {error, map_error_reason(Error)}
    end.

-spec check_value(
    Value :: any(),
    Attr  :: {binary(), jesse:json_term()},
    State :: jesse_state:state()
) ->
    State :: jesse_state:state() |
    no_return().

check_value(Value, {?DISCRIMINATOR, DiscrField}, State) ->
    case jesse_lib:is_json_object(Value) of
        true  -> validate_discriminator(Value, DiscrField, State);
        false -> State
    end;
check_value(Value, Attr = {?REF, Ref}, State) ->
    case is_recursive_ref(Ref, State) of
        true -> State;
        false -> validate_ref(Value, Attr, State)
    end;
check_value(Value, Format = {?FORMAT, _}, State) ->
  validate_format(Value, Format, State);
check_value(Value, Attr, State) ->
    jesse_validator_draft4:check_value(Value, Attr, State).

validate_discriminator(Value, DiscrField, State) when is_binary(DiscrField) ->
    case jesse_json_path:value(DiscrField, Value, ?NOT_FOUND) of
        ?NOT_FOUND ->
            State;
        SchemaName ->
            validate_child_schema(Value, SchemaName, State)
    end.

validate_child_schema(Value, SchemaName, State) ->
    Ref    = <<"#/" ?DEFINITIONS "/", SchemaName/binary>>,
    BadRef = {{packageName}}_utils:to_list(Ref),
    Schema = make_ref_schema(Ref),
    try jesse_schema_validator:validate_with_state(Schema, Value, State)
    catch
        throw:[{schema_invalid, _Schema, {schema_not_found, BadRef}}] ->
            jesse_error:handle_data_invalid(?DISCR_ERROR(SchemaName), Value, State)
    end.

validate_format(Value, {?FORMAT, Format}, State) when
    Format =:= <<"int32">>  orelse
    Format =:= <<"int64">>  orelse
    Format =:= <<"float">>  orelse
    Format =:= <<"byte">>   orelse
    Format =:= <<"binary">> orelse
    Format =:= <<"date">>
->
    case {{packageName}}_param_validator:validate({type, erlang:binary_to_atom(Format, utf8)}, Value) of
        error ->
            jesse_error:handle_data_invalid(wrong_format, Value, State);
        _ ->
            State
    end;
validate_format(Value, Format, State) ->
    jesse_validator_draft4:check_value(Value, Format, State).

validate_ref(Value, Attr = {?REF, Ref} , State) ->
    Path = jesse_state:get_current_path(State),
    State1 = add_ref_to_state(State, ref_tag(Ref, Path)),
    State2 = jesse_validator_draft4:check_value(Value, Attr, State1),
    remove_last_ref_from_state(State2).

add_ref_to_state(State, Ref) ->
    ValState = jesse_state:get_validator_state(State),
    jesse_state:set_validator_state(State, [Ref | ValState]).

remove_last_ref_from_state(State) ->
    case jesse_state:get_validator_state(State) of
        [_ | Rest] ->
            jesse_state:set_validator_state(State, Rest);
        [] ->
            State
    end.

is_recursive_ref(Ref, State) ->
    RefTag = ref_tag(Ref, jesse_state:get_current_path(State)),
    lists:member(RefTag, jesse_state:get_validator_state(State)).

make_ref_schema(Ref) ->
    [{?REF, Ref}].

ref_tag(Ref, Path) ->
    {Ref, Path}.

options() ->
    [{validator, ?MODULE}, {allowed_errors, 0}].

map_error_reason({'data_invalid', _Schema, Error, _Data, Path0}) ->
    Path = get_error_path(Path0),
    Description = get_error_description(Error),
    {{packageName}}_utils:join(".", [Description, Path]).

get_error_path([]) ->
    <<"">>;
get_error_path(Path) ->
    Mapper = fun
        (N) when is_integer(N) -> {{packageName}}_utils:to_binary(N);
        (X)                    -> X
    end,
    PreparedPath = {{packageName}}_utils:join(".", lists:map(Mapper, Path)),
    <<" Path to item: ", PreparedPath/binary>>.

get_error_description(all_schemas_not_valid) ->
    <<"Schema rule \"AllOf\" violated">>;
get_error_description(any_schemas_not_valid) ->
    <<"Schema rule \"AnyOf\" violated">>;
get_error_description({missing_dependency, Dependency0}) ->
    Dependency = {{packageName}}_utils:to_binary(Dependency0),
    <<"Missing dependency \"", Dependency/binary>>;
get_error_description(missing_required_property) ->
    <<"Missing required property">>;
get_error_description(no_extra_items_allowed) ->
    <<"Extra items not allowed">>;
get_error_description(no_extra_properties_allowed) ->
    <<"Extra properties not allowed">>;
get_error_description(no_match) ->
    <<"No match to pattern">>;
get_error_description(not_found) ->
    <<"Not found">>;
get_error_description(not_in_range) ->
    <<"Not in range">>;
get_error_description(not_multiple_of) ->
     <<"Schema rule \"MultipleOf\" violated">>;
get_error_description(not_one_schema_valid) ->
    <<"Schema rule \"OneOf\" violated">>;
get_error_description(not_schema_valid) ->
    <<"Schema rule \"Not\" violated">>;
get_error_description(too_few_properties) ->
    <<"Too few properties">>;
get_error_description(too_many_properties) ->
     <<"Too many properties">>;
get_error_description(wrong_length) ->
    <<"Wrong length">>;
get_error_description(wrong_size) ->
    <<"Wrong size">>;
get_error_description(wrong_type) ->
    <<"Wrong type">>;
get_error_description(wrong_format) ->
    <<"Wrong format">>;
get_error_description(?DISCR_ERROR(SchemaName)) ->
    <<"Discriminator child schema ", SchemaName/binary, " doesn't exist">>.


-ifdef(TEST).
-include_lib("eunit/include/eunit.hrl").

-define(PET_SCHEMA,
  <<"{\"definitions\": {
       \"Pet\": {
         \"type\":          \"object\",
         \"discriminator\": \"type\",
         \"properties\": {
            \"name\":  {\"type\": \"string\"},
            \"owner\": {\"$ref\": \"#/definitions/Owner\"},
            \"type\":  {\"type\": \"string\"}
         },
         \"required\": [\"name\", \"type\"]
       },
       \"Cat\": {
         \"description\": \"A representation of a cat\",
         \"allOf\": [
           {\"$ref\": \"#/definitions/Pet\"},
           {
             \"type\":       \"object\",
             \"properties\": {
               \"huntingSkill\": {
                 \"type\":        \"string\",
                 \"description\": \"The measured skill for hunting\",
                 \"default\":     \"lazy\",
                 \"enum\":        [\"clueless\", \"lazy\", \"adventurous\", \"aggressive\"]
               }
             },
             \"required\": [\"huntingSkill\"]
           }
         ]
       },
       \"Dog\": {
         \"description\": \"A representation of a dog\",
         \"allOf\": [
           {\"$ref\": \"#/definitions/Pet\"},
           {
             \"type\":       \"object\",
             \"properties\": {
               \"packSize\": {
                 \"type\":        \"integer\",
                 \"format\":      \"int32\",
                 \"description\": \"the size of the pack the dog is from\",
                 \"default\":     0,
                 \"minimum\":     0
               }
             }
           }
         ],
         \"required\": [\"packSize\"]
       },
       \"Owner\": {
         \"type\":          \"object\",
         \"discriminator\": \"type\",
         \"properties\": {
            \"soleOwner\": {\"type\": \"boolean\"},
            \"type\": {\"type\": \"string\"}
         },
         \"required\": [\"soleOwner\", \"type\"]
       },
       \"Family\": {
         \"allOf\": [
           {\"$ref\": \"#/definitions/Owner\"},
           {
             \"type\":       \"object\",
             \"properties\": {
               \"members\": {
                 \"type\":  \"array\",
                 \"items\": {\"$ref\": \"#/definitions/Person\"},
                 \"minItems\": 1
               }
             },
             \"required\": [\"members\"]
           }
         ]
       },
       \"Person\": {
         \"allOf\": [
           {\"$ref\": \"#/definitions/Owner\"},
           {
             \"type\":       \"object\",
             \"properties\": {
               \"name\": {\"type\": \"string\"},
               \"age\":  {
                 \"type\":    \"integer\",
                 \"minimum\": 0,
                 \"maximum\": 150
               },
               \"sex\": {
                 \"type\": \"string\",
                 \"enum\": [\"male\", \"female\"]
               },
               \"legalStatus\": {\"$ref\": \"#/definitions/LegalStatus\"}
             },
             \"required\": [\"age\", \"sex\"]
           }
         ]
       },
       \"LegalStatus\": {
         \"type\":          \"object\",
         \"discriminator\": \"status\",
         \"properties\": {
            \"status\": {\"type\": \"string\"}
         },
         \"required\": [\"status\"]
       },
       \"Single\": {
         \"allOf\": [
           {\"$ref\": \"#/definitions/LegalStatus\"},
           {
             \"type\":       \"object\",
             \"properties\": {
               \"minor\": {\"type\": \"boolean\"}
             },
             \"required\": [\"minor\"]
           }
         ]
       },
       \"Married\": {
         \"allOf\": [
           {\"$ref\": \"#/definitions/LegalStatus\"},
           {
             \"type\":       \"object\",
             \"properties\": {
               \"partnerName\": {\"type\": \"string\"}
             },
             \"required\": [\"partnerName\"]
           }
         ]
       }
     }}">>).
-define(PET, 'Pet').

-define(PRED_SCHEMA,
  <<"{\"definitions\": {
       \"Predicate\": {
         \"discriminator\": \"type\",
         \"properties\": {
            \"type\": {\"type\": \"string\"}
         },
         \"required\": [\"type\"]
       },
       \"Constant\": {
         \"allOf\": [
           {\"$ref\": \"#/definitions/Predicate\"},
           {
             \"properties\": {
               \"type\": {
                 \"type\": \"string\",
                 \"enum\": [\"Constant\"]
               },
               \"value\": {
                 \"type\": \"boolean\"
               }
             }
           }
         ]
       },
       \"Conjunction\": {
         \"allOf\": [
           {\"$ref\": \"#/definitions/Predicate\"},
           {
             \"properties\": {
               \"type\": {
                 \"type\": \"string\",
                 \"enum\": [\"Conjunction\"]
               },
               \"operands\": {
                 \"type\": \"array\",
                 \"items\": {\"$ref\": \"#/definitions/Predicate\"}
               }
             }
           }
         ]
       }
     }}">>).
-define(PRED, 'Predicate').

test_validate(Value, DefName, BinSchema) ->
    Schema    = jsx:decode(BinSchema, [return_maps]),
    JsonValue = jsx:decode(Value, [return_maps]),
    case validate(JsonValue, DefName, Schema) of
        ok             -> ok;
        {error, Error} -> Error
    end.

expect(Error, Path) ->
    map_error_reason({data_invalid, undefined, Error, undefined, Path}).

%% Test cases
-spec test() -> _.

-spec good_pet_test() -> _.
good_pet_test() ->
    Pet = <<"{
        \"type\":         \"Cat\",
        \"name\":         \"Flaffy\",
        \"huntingSkill\": \"adventurous\",
        \"owner\": {
            \"type\":      \"Person\",
            \"soleOwner\": true,
            \"name\":      \"Robin\",
            \"age\":       12,
            \"sex\":       \"male\",
            \"legalStatus\": {
                \"status\": \"Single\",
                \"minor\":  true
            }
        }
    }">>,
    ?assertEqual(ok, test_validate(Pet, ?PET, ?PET_SCHEMA)).

-spec wrong_cat_test() -> _.
wrong_cat_test() ->
    Pet = <<"{
        \"name\": \"Fluffy\",
        \"type\": \"Cat\",
        \"huntingSkill\": \"wrong\"
    }">>,
    ?assertEqual(expect(all_schemas_not_valid, []), test_validate(Pet, ?PET, ?PET_SCHEMA)).

-spec person_sex_missing_test() -> _.
person_sex_missing_test() ->
    Pet = <<"{
        \"type\":         \"Cat\",
        \"name\":         \"Fluffy\",
        \"huntingSkill\": \"adventurous\",
        \"owner\": {
            \"type\":      \"Person\",
            \"soleOwner\": true,
            \"name\":      \"true\",
            \"age\":       12,
            \"legalStatus\": {
                \"status\": \"Single\",
                \"minor\":  true
            }
        }
    }">>,
    ?assertEqual(expect(all_schemas_not_valid, [<<"owner">>]), test_validate(Pet, ?PET, ?PET_SCHEMA)).

-spec legal_status_minor_flag_missing_test() -> _.
legal_status_minor_flag_missing_test() ->
    Pet = <<"{
        \"type\":         \"Cat\",
        \"name\":         \"Fluffy\",
        \"huntingSkill\": \"adventurous\",
        \"owner\": {
            \"type\":      \"Person\",
            \"soleOwner\": true,
            \"name\":      \"true\",
            \"age\":       12,
            \"sex\":       \"male\",
            \"legalStatus\": {
                \"status\": \"Single\"
            }
        }
    }">>,
    ?assertEqual(expect(all_schemas_not_valid, [<<"owner">>]), test_validate(Pet, ?PET, ?PET_SCHEMA)).

-spec exceed_int32_swagger_format_test() -> _.
exceed_int32_swagger_format_test() ->
    Pet = <<"{
        \"type\":     \"Dog\",
        \"name\":     \"Rex\",
        \"packSize\": 2147483650,
        \"owner\": {
            \"type\":      \"Person\",
            \"soleOwner\": true,
            \"name\":      \"Robin\",
            \"age\":       12,
            \"sex\":       \"male\",
            \"legalStatus\": {
                \"status\": \"Single\",
                \"minor\":  true
            }
        }
    }">>,
    ?assertEqual(expect(all_schemas_not_valid, []), test_validate(Pet, ?PET, ?PET_SCHEMA)).

-spec good_predicate_test() -> _.
good_predicate_test() ->
    Predicate = <<"{
        \"type\": \"Conjunction\",
        \"operands\": [
          {\"type\": \"Constant\", \"value\": false},
          {
            \"type\": \"Conjunction\",
            \"operands\": [
              {\"type\": \"Constant\", \"value\": false},
              {\"type\": \"Constant\", \"value\": true}
            ]
          }
        ]
    }">>,
    ?assertEqual(ok, test_validate(Predicate, ?PRED, ?PRED_SCHEMA)).

-spec wrong_predicate_test() -> _.
wrong_predicate_test() ->
    Predicate = <<"{
        \"type\": \"Conjunction\",
        \"operands\": [
          {\"type\": \"Constant\", \"value\": false},
          {
            \"type\": \"Conjunction\",
            \"operands\": [
              {\"type\": \"Constant\", \"value\": \"wrong\"},
              {\"type\": \"Constant\", \"value\": true}
            ]
          }
        ]
    }">>,
    ?assertEqual(expect(all_schemas_not_valid, []), test_validate(Predicate, ?PRED, ?PRED_SCHEMA)).
-endif.
