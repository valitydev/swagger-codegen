-module({{packageName}}_validation).

-export([prepare_request_param/3]).
-export([validate_response/2]).

-type validation_error() :: #{
    type := error_type(),
    description => binary()
}.

-type error_type() ::
    no_match |
    not_found |
    not_in_range |
    wrong_length |
    wrong_size |
    schema_violated |
    wrong_type |
    wrong_array.

-type value() :: term().

-export_type([validation_error/0]).
-export_type([error_type/0]).
-export_type([value/0]).

-define(catch_error(Block),
    try
        {ok, Block}
    catch
        throw:{wrong_param, _Name, Errors} ->
            {error, Errors}
    end
).

-spec prepare_request_param(
    [{{packageName}}_validation_schema:rule()],
    {{packageName}}_validation_schema:param_name(),
    value()
) ->
    {ok, term()} |
    {error, validation_error()}.

prepare_request_param(Rules, Name, Value) ->
    ?catch_error(validate_param(Rules, Name, Value)).

-spec validate_response(
    {{packageName}}_validation_schema:response_spec(),
    value()
) ->
    ok |
    {error, validation_error()}.

validate_response({DataType, BaseType}, Body) ->
    Result = case DataType of
        'list' ->
            ?catch_error(
                [validate(schema, BaseType, Item) || Item <- Body]
            );
        _ ->
            ?catch_error(validate(schema, BaseType, Body))
    end,
    case Result of
        E = {error, _} -> E;
        _ -> ok
    end;

validate_response(undefined, undefined) ->
    ok;

validate_response(undefined, _) ->
    #{
        type => schema_violated,
        description => <<"Must be empty">>
    }.

validate(Rule = schema, Name, Value) ->
    case {{packageName}}_schema_validator:validate(Value, Name) of
        ok ->
            ok;
        {error, Reasons} when is_list(Reasons) ->
            Errors = [map_error(Rule, R) || R <- Reasons],
            report_validation_errors(Name, Errors)
    end;

validate(Rule, Name, Value) ->
    case {{packageName}}_param_validator:validate(Rule, Value) of
        ok ->
            ok;
        Ok = {ok, _} ->
            Ok;
        error ->
            report_validation_error(Rule, Name)
    end.

-spec report_validation_error(
    {{packageName}}_validation_schema:rule(),
    {{packageName}}_validation_schema:param_name()
) ->
    no_return().

report_validation_error(Rule, Name) ->
    Errors = [map_error(Rule)],
    report_validation_errors(Name, Errors).

-spec report_validation_errors(
    {{packageName}}_validation_schema:param_name(),
    [{{packageName}}_validation:validation_error()]
) ->
    no_return().

report_validation_errors(Name, Errors) ->
    throw({wrong_param, Name, Errors}).

validate_param(Rules, Name, Value) ->
    lists:foldl(
        fun(Rule, Acc) ->
            case validate(Rule, Name, Acc) of
                ok -> Acc;
                {ok, Prepared} -> Prepared
            end
        end,
        Value,
        Rules
    ).

map_error(Rule) ->
    map_error(Rule, undefined).

map_error(Rule, Description) ->
    Error = #{
        type => map_violated_rule(Rule)
    },
    case Description of
        undefined -> Error;
        _ -> Error#{description => Description}
    end.

-spec map_violated_rule(
    {{packageName}}_validation_schema:rule()
) ->
    error_type().

map_violated_rule({type, _Type}) ->  wrong_type;
map_violated_rule({enum, _}) ->  not_in_range;
map_violated_rule({max, _, _}) ->  wrong_size;
map_violated_rule({min, _, _}) ->  wrong_size;
map_violated_rule({max_length, _}) ->  wrong_length;
map_violated_rule({min_length, _}) ->  wrong_length;
map_violated_rule({pattern, _}) ->  no_match;
map_violated_rule(schema) ->  schema_violated;
map_violated_rule({required, _}) ->  not_found;
map_violated_rule({list, _, _}) ->  wrong_array.
