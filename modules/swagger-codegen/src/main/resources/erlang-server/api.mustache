-module({{packageName}}_api).

-export([populate_request/3]).
-export([validate_response/4]).

-type operation_id() :: atom().
-type request_param() :: atom().


-type request_context() :: #{
    auth_context => AuthContext :: {{packageName}}_auth:context(),
    peer => client_peer()
}.

-type client_peer() :: #{
    ip_address => IP :: inet:ip_address(),
    port_number => Port :: inet:port_number()
}.

-export_type([operation_id/0]).
-export_type([request_context/0]).
-export_type([client_peer/0]).

-spec request_params(OperationID :: operation_id()) -> [Param :: request_param()].
{{#apiInfo}}{{#apis}}
{{#operations}}{{#operation}}
request_params('{{operationId}}') ->
    [{{#allParams}}{{^isBodyParam}}
        '{{baseName}}'{{/isBodyParam}}{{#isBodyParam}}
        '{{dataType}}'{{/isBodyParam}}{{#hasMore}},{{/hasMore}}{{/allParams}}
    ];
{{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}
request_params(_) ->
    error(unknown_operation).

-spec populate_request(
    OperationID :: operation_id(),
    Req :: cowboy_req:req(),
    {{packageName}}_server:id()
) ->
    {ok, Model :: map(), Req :: cowboy_req:req()} |
    {error, Reason :: unavailable | binary(), Req :: cowboy_req:req()}.

populate_request(OperationID, Req, ID) ->
    Params = request_params(OperationID),
    populate_request_params(OperationID, Params, Req, #{}, ID).

populate_request_params(_, [], Req, Model, _) ->
    {ok, Model, Req};

populate_request_params(OperationID, [FieldParams | T], Req0, Model, ID) ->
    case populate_request_param(OperationID, FieldParams, Req0, ID) of
        {ok, K, V, Req} ->
            populate_request_params(OperationID, T, Req, maps:put(K, V, Model), ID);
        Error ->
            Error
    end.

populate_request_param(OperationID, Name, Req0, ID) ->
    #{rules := Rules, source := Source} = {{packageName}}_validation:request_param_info(OperationID, Name),
    case get_value(Source, Name, Req0) of
        {ok, Value, Req} ->
            case {{packageName}}_validation:prepare_param(Rules, Name, Value, ID) of
                {ok, Result} ->
                    {ok, Name, Result, Req};
                {error, Error = #{type := _}}  ->
                    {error, error_message(Name, Error), Req};
                {error, Reason} ->
                    {error, Reason, Req}
            end;
        E = {error, _, _} ->
            E
    end.

-spec validate_response(
    OperationID :: operation_id(),
    Code :: 200..599,
    Body :: jesse:json_term() | undefined,
    {{packageName}}_server:id()
) -> ok | no_return().

validate_response(OperationID, Code, Body, ID) ->
    ok = {{packageName}}_validation:validate_response(OperationID, Code, Body, ID).

get_value(body, _Name, Req0) ->
    {ok, Body, Req} = cowboy_req:body(Req0),
    case prepare_body(Body) of
        {ok, Value} ->
            {ok, Value, Req};
        {error, Reason} ->
            {error, Reason, Req}
    end;

get_value(qs_val, Name, Req0) ->
    {QS, Req} = cowboy_req:qs_vals(Req0),
    Value = {{packageName}}_utils:get_opt({{packageName}}_utils:to_qs(Name), QS),
    {ok, Value, Req};

get_value(header, Name, Req0) ->
    {Headers, Req} = cowboy_req:headers(Req0),
    Value = {{packageName}}_utils:get_opt({{packageName}}_utils:to_header(Name), Headers),
    {ok, Value, Req};

get_value(binding, Name, Req0) ->
    {Bindings, Req} = cowboy_req:bindings(Req0),
    Value = {{packageName}}_utils:get_opt({{packageName}}_utils:to_binding(Name), Bindings),
    {ok, Value, Req}.

prepare_body(Body) ->
    try
        {ok, jsx:decode(Body, [return_maps])}
    catch
        _:_ ->
            {error, <<"Invalid json">>}
    end.

-spec error_message(request_param(), {{packageName}}_validation:validation_error()) -> binary().

error_message(Name, Error = #{type := Type}) ->
    jsx:encode(#{
        <<"name">> => {{packageName}}_utils:to_binary(Name),
        <<"errorType">> => {{packageName}}_utils:to_binary(Type),
        <<"description">> => maps:get(description, Error, <<"">>)
    }).
