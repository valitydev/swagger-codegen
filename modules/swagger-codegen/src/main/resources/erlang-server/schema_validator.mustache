-module({{packageName}}_schema_validator).

-behaviour(gen_server).

%% API
-export([child_spec/2]).
-export([start_link/1]).
-export([validate/3]).

%% gen_server behaviour callbacks
-export([init/1]).
-export([handle_call/3]).
-export([handle_cast/2]).
-export([handle_info/2]).
-export([code_change/3]).
-export([terminate/2]).

-export_type([pool_options/0]).
-export_type([raw_schema/0]).
-export_type([params/0]).
-export_type([type/0]).

-type pool_options() :: #{
    max_count            => non_neg_integer(),
    init_count           => non_neg_integer(),
    cull_interval        => pool_time_interval(),
    max_age              => pool_time_interval(),
    member_start_timeout => pool_time_interval()
}.
-type raw_schema() :: {{packageName}}_schema_validator_worker:raw_schema().
-type params() :: #{
    validator_pool_opts => pool_options(),
    swagger_schema      => raw_schema()
}.
-type type() :: request | response.

-type pool_time_interval() :: {non_neg_integer(), min | sec | ms}.
-type state()     :: {{packageName}}_schema_validator_worker:schema().
-type init_data() :: raw_schema() | undefined.

-define(DEFAULT_POOL_OPTIONS, #{
    init_count => 1,
    max_count  => 20
}).
-define(DEFAULT_TAKE_TIMEOUT, {3, sec}).
-define(POOL_ID,              <<"{{basePath}}">>). %% ToDo: add a param specifying the role [server | client].

%%

-spec child_spec(Type :: type(), Params :: params()) ->
    ChildSpec :: supervisor:child_spec().

child_spec(Type, Params) ->
    PoolOpts0 = maps:get(validator_pool_opts, Params, #{}),
    Schema    = maps:get(swagger_schema, Params, undefined),
    PoolOpts1 = PoolOpts0#{
        start_mfa => {?MODULE, start_link, [Schema]},
        name      => construct_pool_name(Type)
    },
    pooler:pool_child_spec(maps:to_list(maps:merge(?DEFAULT_POOL_OPTIONS, PoolOpts1))).

-spec start_link(init_data()) ->
    {ok, pid()}.

start_link(Options) ->
    gen_server:start_link(?MODULE, Options, []).

-spec validate(Type :: type(), Value :: swagger:value(), Defname :: swagger:param_name()) ->
    ok | {error, Error :: swagger:error_reason() | validator_unavailable}.

validate(Type, Value, Defname) ->
    PoolName = construct_pool_name(Type),
    case pooler:take_member(PoolName, ?DEFAULT_TAKE_TIMEOUT) of
        Pid when is_pid(Pid) ->
            try
                Result = call_validator(Pid, Value, Defname),
                ok = pooler:return_member(PoolName, Pid, ok),
                Result
            catch Class:Reason ->
                ok = pooler:return_member(PoolName, Pid, fail),
                erlang:raise(Class, Reason, erlang:get_stacktrace())
            end;
        error_no_members ->
            {error, validator_unavailable}
    end.

%%

construct_pool_name(request) ->
    construct_pool_name(<<"request">>);
construct_pool_name(response) ->
    construct_pool_name(<<"response">>);
construct_pool_name(Type) when is_binary(Type) ->
    binary_to_atom(<<?MODULE_STRING, $_, ?POOL_ID/binary, $_, Type/binary>>, utf8).

call_validator(Pid, Value, Defname) ->
    gen_server:call(Pid, {validate, Value, Defname}).

%%

-spec init(init_data()) ->
    {ok, init_data()}.

init(Schema) when is_binary(Schema) orelse Schema =:= undefined ->
    gen_server:cast(self(), init),
    {ok, Schema}.

-spec handle_call(
    {validate, Value :: {{packageName}}:value(), Defname :: {{packageName}}:param_name()} | _,
    _From,
    state()
) ->
    {reply, ok | {error, Error :: {{packageName}}:error_reason()}, state()} |
    {noreply, state()}.

handle_call({validate, Json, Defname}, _From, Schema) ->
    Result = {{packageName}}_schema_validator_worker:validate(Json, Defname, Schema),
    {reply, Result, Schema};
handle_call(_Call, _From, State) ->
    {noreply, State}.

-spec handle_cast(init,  State :: init_data()) -> {noreply, state()};
                 (_Cast, State :: state()) ->     {noreply, state()}.

handle_cast(init, undefined) ->
    {noreply, {{packageName}}_schema_validator_worker:init_schema()};
handle_cast(init, BinSchema) ->
    {noreply, {{packageName}}_schema_validator_worker:init_schema(BinSchema)};
handle_cast(_Cast, State) ->
    {noreply, State}.

-spec handle_info(_Info, state()) ->
    {noreply, state()}.

handle_info(_Info, State) ->
    {noreply, State}.

-spec code_change(_, state(), _) ->
    {ok, state()}.
code_change(_, State, _) ->
    {ok, State}.

-spec terminate(_Reason, state()) ->
    ok.
terminate(_, _) ->
    ok.
